<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>github技术小册</title>
    <url>/blog/2020/04/07/github%E6%8A%80%E6%9C%AF%E5%B0%8F%E5%86%8C/</url>
    <content><![CDATA[<p>日常开发工作中的一些技术心得：</p>
<p><a href="https://github.com/MrRRRabbit/daydaynote" target="_blank" rel="noopener">传送门</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-面试题17.13</title>
    <url>/blog/2020/07/09/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9817-13/</url>
    <content><![CDATA[<blockquote>
<p>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子”I reset the computer. It still didn’t boot!”已经变成了”iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</p>
<p><strong>注意：</strong>本题相对原题稍作改动，只需返回未识别的字符数</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">dictionary &#x3D; [&quot;looked&quot;,&quot;just&quot;,&quot;like&quot;,&quot;her&quot;,&quot;brother&quot;]</span><br><span class="line">sentence &#x3D; &quot;jesslookedjustliketimherbrother&quot;</span><br><span class="line">输出： 7</span><br><span class="line">解释： 断句后为&quot;jess looked just like tim her brother&quot;，共7个未识别字符。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>0 &lt;= len(sentence) &lt;= 1000</li>
<li>dictionary中总字符数不超过 150000。</li>
<li>你可以认为dictionary和sentence中只包含小写字母。</li>
</ul>
</blockquote>
<p>题解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>思考</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/blog/2020/03/31/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>欢迎</title>
    <url>/blog/2020/04/01/%E6%AC%A2%E8%BF%8E/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"欢迎来到我的国度！！！"</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>welcome</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-309</title>
    <url>/blog/2020/07/10/leetcode-309/</url>
    <content><![CDATA[<blockquote>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>示例:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>题解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>思考</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>动态代理-cglib与jdk方式差异解析</title>
    <url>/blog/2020/07/12/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-cglib%E4%B8%8Ejdk%E6%96%B9%E5%BC%8F%E5%B7%AE%E5%BC%82%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="两种代理模式差异"><a href="#两种代理模式差异" class="headerlink" title="两种代理模式差异"></a>两种代理模式差异</h2><table>
<thead>
<tr>
<th>代理类型</th>
<th>Cglib</th>
<th>Jdk</th>
</tr>
</thead>
<tbody><tr>
<td>是否需要实现接口</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>依赖</td>
<td>需依赖cglib类库</td>
<td>只依赖jdk</td>
</tr>
<tr>
<td>字节码生成</td>
<td>ASM框架</td>
<td>根据Class文件的格式规范调用sun.misc.ProxyGenerator.generateProxyClass()直接拼装字节码</td>
</tr>
<tr>
<td>代理方法调用</td>
<td>FastClass机制直接调用</td>
<td>反射机制调用</td>
</tr>
</tbody></table>
<h3 id="演示demo"><a href="#演示demo" class="headerlink" title="演示demo"></a>演示demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetImpl</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Target target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JdkProxy</span><span class="params">(Target target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Target <span class="title">newProxyInstance</span><span class="params">(Target target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Target) Proxy</span><br><span class="line">            .newProxyInstance(JdkProxy.class.getClassLoader(), new Class[]&#123;Target.class&#125;, new JdkProxy(target));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Target <span class="title">newProxyInstance</span><span class="params">(Target target)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> CglibProxy());</span><br><span class="line">        <span class="keyword">return</span> (Target) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h2><table>
<thead>
<tr>
<th>jdk版本</th>
<th>小于1.8</th>
<th>大于1.8</th>
</tr>
</thead>
<tbody><tr>
<td>代理创建性能</td>
<td>Jdk &gt; Cglib</td>
<td>Jdk &gt; Cglib</td>
</tr>
<tr>
<td>代理运行性能</td>
<td>Jdk &lt; Cglib</td>
<td>Jdk &gt; Cglib</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-167</title>
    <url>/blog/2020/07/20/leetcode-167/</url>
    <content><![CDATA[<blockquote>
<p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<p><strong>说明:</strong></p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>题解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; numbers.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index1 &gt;= index2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (target == numbers[index1] + numbers[index2]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;index1 + <span class="number">1</span>, index2 + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; numbers[index1] + numbers[index2]) &#123;</span><br><span class="line">                index1++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; numbers[index1] + numbers[index2]) &#123;</span><br><span class="line">                index2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">                                 |</span><br><span class="line">                                 |</span><br><span class="line">                                \|/</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; index2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == numbers[index1] + numbers[index2]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;index1 + <span class="number">1</span>, index2 + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; numbers[index1] + numbers[index2]) &#123;</span><br><span class="line">                index1++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; numbers[index1] + numbers[index2]) &#123;</span><br><span class="line">                index2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>思考</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">以上两种遍历方式，虽然在循环跳出的条件上有所差异，但是理论上找到解的遍历次数应该是相同的，但是在LeetCode提交后两者的执行耗时确有差别，解法1更加耗时，为什么？</span><br><span class="line">ps：此种情况不是必现，只有在某些testCase下复现，应该是在数组数量很多，且出现极端情况，遍历次数想多较多的时候，才会出现</span><br><span class="line"></span><br><span class="line">个人猜测是由于解法1比叫法2要多一段判断逻辑，这种微小的开销在遍历次数很少的情况下，可以忽略，但是在遍历很多次的情况下，这种开销会被放大，导致两者的耗时有差异</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1469</title>
    <url>/blog/2020/07/23/leetcode-1469/</url>
    <content><![CDATA[<blockquote>
<p>二叉树中，如果一个节点是其父节点的唯一子节点，则称这样的节点为 “<strong>独生节点</strong>” 。二叉树的根节点不会是独生节点，因为它没有父节点。</p>
<p>给定一棵二叉树的根节点 <code>root</code> ，返回树中 <strong>所有的独生节点的值所构成的数组</strong> 。数组的顺序 <strong>不限</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh0qftdoiyj305n05mjra.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,null,4]</span><br><span class="line">输出：[4]</span><br><span class="line">解释：浅蓝色的节点是唯一的独生节点。</span><br><span class="line">节点 1 是根节点，不是独生的。</span><br><span class="line">节点 2 和 3 有共同的父节点，所以它们都不是独生的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh0qgr52kwj30ca07umx9.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [7,1,4,6,null,5,3,null,null,null,null,null,2]</span><br><span class="line">输出：[6,2]</span><br><span class="line">输出：浅蓝色的节点是独生节点。</span><br><span class="line">请谨记，顺序是不限的。 [2,6] 也是一种可接受的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh0qh2ajh0j30a305mq2z.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [11,99,88,77,null,null,66,55,null,null,44,33,null,null,22]</span><br><span class="line">输出：[77,55,33,66,44,22]</span><br><span class="line">解释：节点 99 和 88 有共同的父节点，节点 11 是根节点。</span><br><span class="line">其他所有节点都是独生节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [197]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [31,null,78,null,28]</span><br><span class="line">输出：[78,28]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>tree</code> 中节点个数的取值范围是 <code>[1, 1000]</code>。</li>
<li>每个节点的值的取值范围是 <code>[1, 10^6]</code>。</li>
</ul>
</blockquote>
<p>题解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getLonelyNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(root)) &#123;</span><br><span class="line">            <span class="keyword">return</span> results;</span><br><span class="line">        &#125;</span><br><span class="line">        fetchNode(root, results);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fetchNode</span><span class="params">(TreeNode node, List&lt;Integer&gt; results)</span> </span>&#123;</span><br><span class="line">        TreeNode left = node.left;</span><br><span class="line">        TreeNode right = node.right;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(left) &amp;&amp; !Objects.isNull(right)) &#123;</span><br><span class="line">            results.add(right.val);</span><br><span class="line">            fetchNode(right, results);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!Objects.isNull(left) &amp;&amp; Objects.isNull(right)) &#123;</span><br><span class="line">            results.add(left.val);</span><br><span class="line">            fetchNode(left, results);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!Objects.isNull(left) &amp;&amp; !Objects.isNull(right)) &#123;</span><br><span class="line">            fetchNode(right, results);</span><br><span class="line">            fetchNode(left, results);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">private</span> TreeNode left;</span><br><span class="line">    <span class="keyword">private</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-04.02</title>
    <url>/blog/2020/07/27/leetcode-04-02/</url>
    <content><![CDATA[<blockquote>
<p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      0 </span><br><span class="line">     &#x2F; \ </span><br><span class="line">   -3   9 </span><br><span class="line">   &#x2F;   &#x2F; </span><br><span class="line"> -10  5 </span><br></pre></td></tr></table></figure>
</blockquote>
<p>题解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildNode(<span class="number">0</span>, nums.length - <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildNode</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(nums[end]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> midIndex = (begin + end + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(nums[midIndex]);</span><br><span class="line">        node.left = buildNode(begin, midIndex - <span class="number">1</span>, nums);</span><br><span class="line">        node.right = buildNode(midIndex + <span class="number">1</span>, end, nums);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>思考</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 在求数组的中位索引的时候，主要在begin和end这两个索引在求和为奇数的时，会导致最后生成的BST的某个子树的左节点大于右节点，因此在求中位索引的时候，需要在begin和end求和基础上再加1再求中位索引</span><br><span class="line">2. 在使用递归生成左右子节点的时候，方法入参的begin和end都需要注意排除已经成为节点的数的索引</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-offer27</title>
    <url>/blog/2020/07/27/leetcode-offer27/</url>
    <content><![CDATA[<blockquote>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p><strong>例如输入：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        4</span><br><span class="line">      &#x2F;   \</span><br><span class="line">    2     7</span><br><span class="line">  &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p><strong>镜像输出：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        4</span><br><span class="line">      &#x2F;   \</span><br><span class="line">    7     2</span><br><span class="line">  &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>



<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<p><code>0 &lt;= 节点个数 &lt;= 1000</code></p>
</blockquote>
<p>题解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(root)) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(root.left) &amp;&amp; Objects.isNull(root.right)) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        mirrorTree(root.left);</span><br><span class="line">        mirrorTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-offer55-I</title>
    <url>/blog/2020/07/27/leetcode-offer55-I/</url>
    <content><![CDATA[<blockquote>
<p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  15   7</span><br></pre></td></tr></table></figure>


<p>返回它的最大深度 3 。</p>
<p><strong>提示：</strong></p>
<p><code>节点总数 &lt;= 10000</code></p>
</blockquote>
<p>题解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(root)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!Objects.isNull(root.left)) &#123;</span><br><span class="line">            leftDepth = maxDepth(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rightDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!Objects.isNull(root.right)) &#123;</span><br><span class="line">            rightDepth = maxDepth(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootDepth = Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> rootDepth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">                                   |</span><br><span class="line">                                   |</span><br><span class="line">                                  \|/</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(root)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (!Objects.isNull(node.left)) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!Objects.isNull(node.right)) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>思考</p>
<p>树的遍历可分为，其中前三种为DFS（深度优先搜索），最后一种为BFS（广度优先搜索）</p>
<ol>
<li>前序遍历：根结点 –&gt; 左子树 –&gt; 右子树</li>
<li>中序遍历：左子树 –&gt; 根结点 –&gt; 右子树</li>
<li>后序遍历：左子树 –&gt; 右子树 –&gt; 根结点</li>
<li>层次遍历：只需按层次遍历即可</li>
</ol>
<p><strong>题解1</strong> 采用DFS深度优先搜索对树进行后序遍历，参考下列示意图</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5ojez1eyj30tt0me75j.jpg" alt="Picture1.png"></p>
<p><strong>题解2</strong> 采用BFS，需要借助队列，逐层遍历，每遍历完一层，深度加1，空间复杂度稍高</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>后序遍历</tag>
      </tags>
  </entry>
</search>
